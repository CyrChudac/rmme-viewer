<template>
  <div>
    <no-data v-if="!dataAvailable" />
    <d3-line-plot
      v-else
      :data="plotData"
      :text="plotText"
      :heightModifier=3
      :resize-notification="resizeNotification"
      :args="args"
    />
  </div>
</template>

<script>
  import LinePlot from "../d3js/line-plot";
  import NoData from "../ui/no-data";

  import {rangeByStep, unifiedRound} from "./views-utils";
  import {STATUS_OK, STATUS_WARNING, STATUS_INVALID, worstStatus} from "../data-status";

  export default {
    "validator": validateData,
    "thresholds": defaultTresholds,
    "parentDisplaysError": isParentDisplayingErrors,
    "label": "GC content",
    //
    "name": "gc-content",
    "components": {
      "d3-line-plot": LinePlot,
      "no-data": NoData,
    },
    "props": {
      "data": {"type": Object, "required": true},
      "options": {"type": Object, "required": true},
      "resizeNotification": {"type": Object, "require": true},
    },
    "computed": {
      "dataAvailable": function(){
        return selectData(this.data) != null;
      },
      "plotData": function () {
        const data = selectData(this.data);
        let ref = selectRef(this.data);
        const options = selectData(this.options);
        let result =  [
          {
            "label": "First fragment",
            "color": options["gcf"],
            "y": data["gcf-y"],
            "x": data["gcf-x"]
          }, {
            "label": "Last fragment",
            "color": options["gcl"],
            "y": data["gcl-y"],
            "x": data["gcl-x"]
          }
        ];
        if(ref){
          if(!ref["mapped"]){
            let ratio = data["gcl-x"][data["gcl-x"].length - 1] / ref["ref-x"][ref["ref-x"].length - 1];
            ref["ref-x"] = ref["ref-x"].map(value => value * ratio);
            ref["mapped"] = true;
          }
          result.push({
            "label": "Reference",
            "color": options["ref"],
            "y": ref["ref-y"],
            "x": ref["ref-x"],
          });
        }
        return result;
      },
      "plotText": function() {
        const data = selectData(this.data);
        return data["text"];
      },
      "args": function() {
        const options = selectData(this.options);
        return {
          "margin": options["margin"],
        }
      }
    }
  };

  function selectData(data) {
    return data["gc-content"];
  }

  function selectRef(data) {
    return data["gc-content-ref"];
  }

  function isParentDisplayingErrors(){
    return true;
  }
  
  function defaultTresholds(){
    return {
      "Bad": 30,
      "Ok": 15,
      "legend": "maximal % difference of actual value and average of surounding ones"
    }
  }
  
  let quiet = true;
  function validateData(data, thresholds, forceCompute=false) {
    data = selectData(data);
    if(data["status"] && !forceCompute){
      return data["status"];
    }else{
      let status = STATUS_OK;
      let message = "";

      for (let index = 1; index < data["count"] - 1; ++index) {
        let curr = validateSpecificIndex(index, data, thresholds);
        if(curr["status"] === STATUS_INVALID){
          if(status != STATUS_INVALID){
            message = "";
          }
          message += curr["message"];
          status = STATUS_INVALID;
        }
        else if (curr["status"] === STATUS_WARNING && status != STATUS_INVALID){
          message += curr["message"];
          status = STATUS_WARNING;
        }
      }
      if(status != STATUS_OK){
        message = "Folowing fragments are in worst state:\n" + message;
      }
      let result = {
        "status": status,
        "message": message,
      }
      data["status"] = result;
      if(!quiet){
        console.log("maximal difference in GC content was " + unifiedRound(maxDiff*100) + "%");
        //console.log(diffMessage);
      }
      return result;
    }
  }

  function validateSpecificIndex(index, data, thresholds){
    let gcf = validateIndexOnString(data, "gcf-y", "gcf-x", index, thresholds);
    let gcl = validateIndexOnString(data, "gcl-y", "gcl-x", index, thresholds);
    let worst = worstStatus([gcf, gcl]);
    let message = "";
    if(worst != STATUS_OK){
      if(gcl === worst){
        message = "last on " + Math.round(data["gcl-x"][index]) + ", ";
      }
      else{
        message = "first on " + Math.round(data["gcf-x"][index]) + ", ";
      }
    }
    return {
      "status": worst,
      "message": message,
    };
  }
  
  function validateIndexOnString(data, stringY, stringX, index, thresholds){
    let currVal = data[stringY][index];
    let currX = data[stringX][index];

    let prevIndex = Math.max(index - 1, 0);
    let previousY = data[stringY][prevIndex];
    let previousX = data[stringX][prevIndex];
    let upcomIndex = Math.min(index + 1, data[stringX].length - 1);
    let upcomingY = data[stringY][upcomIndex];
    let upcomingX = data[stringX][upcomIndex];

    let distance = upcomingX - previousX; 
    let average = (previousY * (upcomingX - currX) + upcomingY * (currX - previousX))/distance;
    let status;
    if(isTresholdOk(thresholds["Ok"], currVal, average, currX)){
      status = STATUS_OK;
    }
    else if (isTresholdOk(thresholds["Bad"], currVal, average, currX)){
      status = STATUS_WARNING;
    }else{
      /*/
      //uncomment to activate console output
      
      console.log(index + ", " + currX + ": " + currVal + " not in (" + average * (1 - (thresholds["Bad"]/100)) + ", "
       + average * (1 + (thresholds["Bad"]/100)) + ") - average = " + average + " (all rounded by unifiedRound)");
      console.log(average + " = (" + previousY + " * " + " (" + upcomingX + " - " + currX + ") + "
       + upcomingY + " * (" + currX + " - " + previousX + ")) / (" + upcomingX + " - " + previousX + ")");
      /**/
      status = STATUS_INVALID;
    }
    return status;
  }

  let maxDiff = 0;
  let diffMessage = "no message yet";
  function isTresholdOk(treshold, currVal, average, index){
    if(!quiet){
      if(average != 0 && currVal != 0 
      && unifiedRound(average, 1000) != 0 && unifiedRound(currVal, 1000) != 0){
        let diff = 1 - currVal / average;
        if (Math.abs(diff) > Math.abs(maxDiff)){
          maxDiff = diff;
          diffMessage = index + ": 1 - (" + currVal + " / " + average + ") = " + diff
            + "\n" + currVal + " >= " + unifiedRound(average * (1 - (treshold/100)))
            + "\n" + currVal + " <= " + unifiedRound(average * (1 + (treshold/100)))
            ;
        }
      }
    }
    currVal = unifiedRound(currVal);
    return currVal >= unifiedRound(average * (1 - (treshold/100)))
     && currVal <= unifiedRound(average * (1 + (treshold/100)));
  }
</script>